# define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//数组是一组相同类型的数据的集合
//在C99标准上数组的大小可以是变量
//数组的创建方式：
//typr_t arr_name[const_n];
//type_t 数组类型
//const_n 常量或常量表达式。用来决定数组大小

//
//int main()
//{
//	//不完全初始化，剩下的位置的元素默认初始化为0
//	int arr[10] = { 1,2,3 };
//	int ch1[10] = { 'a' , 'b' , 'c' };
//	int ch2[10] = "abc";
//	int ch3[] = "abc";//不写大小编译器会根据内容自动决定大小
//	//  []  这个方框是下标引用操作符
//
//	return 0;
//}

//一位数组在内存中的存储
//int main()
//{
//	int arr[] = {1,2,3,4,5,6,7,8,9,10};
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[1]);
//	//打印数组中每一个元素的地址
//	for (i = 0; i <= sz - 1; i++)
//	{
//		printf("&arr[%d] = %p\n", i, &arr[i]);//%p打印地址
//		//每个整型占一个字节，所以每一个打印出来的地址相差4
//		//数组在内存中是连续存放的，数组下标增长，元素的地址也随之有规律的递增
//	}
//	return 0;
//}

//二维数组的创建与存储
//int main()
//{
//	//二维数组中行可以胜率，但是列不可以省略
//	int arr0[][4] = { {1,2,3,4},{2,3} };//二维数组的创建，第一个[]是行，第二个[]是列  这种创建方法可以明确区分每一行的元素
//	//可以把二维数组理解为一维数组的数组。
//	//通过arr[0][i] 其中i为任意取值，可以访问第0行的任意元素，那么就可以把arr[0]看做为一个数组名。
//
//	//而三维数组只能省略第一个[]的内容
//
//	int arr[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };
//	int i = 0;
//	for ( i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for ( j = 0; j < 4; j++)
//		{
//			printf("%d ", arr[i][j]);//二维数组的访问，类似与坐标定位
//		}
//		printf("\n");
//	}
//
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			printf("arr[%d][%d]=%p\n", i, j,&arr[i][j]);//二维数组的存放也是来连续的，其中每一个元素的内存都差4
//			//二维数组的存储可以看成是连续的一维数组的存储，比如arr[3][4]={1,2,3,4,2,3,4,5,3,4,5,6}这个二维数组就可以看成是按照1,2,3,4,2,3,4,5,3,4,5,6来存储的
//		}
//		printf("\n");
//	}
//
//	return 0;
//}

//数组越界
//n个元素的数组，如果下标小于0或者大于n-1就会造成数组越界访问，编译器不一定会报错，需要自己检查



//数组传参有两种写法
//1.数组
//2.指针
//void bubble_sort(int arr[], int sz)//数组的写法，里面的arr[]可以不写数组大小，写了也没用。函数内部无法求数组大小
//{
//
//	//为什么不能在函数内部求数组大小？
//	//数组名本质上是数组首元素的地址，在传参的时候传的就是这个地址
//	//上面的int arr[]看似是数组，本质是指针变量，其大小是8
//	//很容易知道：int sz = sizeof(arr) / sizeof(arr[0]);   这一行代码的结果是8，并非正确结果。
//
//	//冒泡排序的核心思想：
//	//两个相邻的元素进行比较
//	//一趟冒泡排序让一个数据去到目标位置上
//	//而n个元素需要n-1趟冒泡排序
//	int i = 0;
//	for (i = 0;i < sz - 1; i++)//需要排sz-1趟，因为排完n-1个数字后最后一个数字的位置肯定也确定了
//	{
//		int j = 0;
//		//一趟冒泡排序
//		for ( j = 0; j < sz - 1 - i; j++)//第一趟要排sz-1次，排完后剩下sz-1个数字，要排sz-2次，以此类推
//		{
//			if (arr[j] > arr[j + 1])//不符合顺序，交换
//			{
//				int temp = 0;
//				temp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = temp;
//			}
//		}
//	}
//}
//int main()
//{
//	//把数组的数据升序 即输出 0 1 2 3 4 5 6 7 8 9
//	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//冒泡排序的算法
//	bubble_sort(arr, sz);//给数组传参的时候直接传数组名字就好了，数组名的实质就是地址
//	int i = 0;
//	printf("排序后的结果：");
//	for ( i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}


//数组名是什么?
//数组名确实能表示首元素的地址
//但是有两个例外：
//1.sizeof(数组名)  这里的数组名表示的是整个数组 计算的是整个数组的大小 单位是字节
//2.&数组名  这里的数组名表示的是整个数组，取出来的是整个数组的地址
//int main()
//{
//	int arr[10];
//	printf("%p\n", arr);//arr就是首元素的地址
//	printf("%p\n", arr + 1);
//	printf("-------------------------\n");
//	printf("%p\n", &arr[0]);//首元素的地址
//	printf("%p\n", &arr[0] + 1);
//	printf("-------------------------\n");
//	printf("%p\n", &arr);//整个数组的地址  0000001F2F4FF6D8
//	printf("%p\n", &arr + 1);//整个数组的下一个的地址 0000001F2F4FF700
//	return 0;
//}
//int main()
//{
//	int arr[3][4];
//	int sz = sizeof(arr);//48
//
//	printf("%d\n", sizeof(arr) / sizeof(arr[0]));//求行数  总大小/第一行的大小
//	printf("%d\n", sizeof(arr[0]) / sizeof(arr[0][0]));//求列数  第一行的大小/第一行第一个的大小（相当于一维数组求个数）
//
//	arr;//二维数组的数组名也表示首元素的地址，二维数组是连续的一维数组，一行就是一个元素，第一行就是首元素，而第一行是一位数组，其首元素就是其地址
//	printf("%p\n", arr + 1);//这里是输出第二行的地址
//	return 0;
//}